{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\nvar _ = require('underscore');\n\nvar utils = require('web3-utils');\n\nvar BN = require('bn.js');\n\nvar SolidityParam = require('./param');\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BN} value that needs to be formatted\n * @returns {SolidityParam}\n */\n\n\nvar formatInputInt = function (value) {\n  if (_.isNumber(value)) {\n    value = Math.trunc(value);\n  }\n\n  return new SolidityParam(utils.toTwosComplement(value).replace('0x', ''));\n};\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String} value\n * @returns {SolidityParam}\n */\n\n\nvar formatInputBytes = function (value) {\n  if (!utils.isHexStrict(value)) {\n    throw new Error('Given parameter is not bytes: \"' + value + '\"');\n  }\n\n  var result = value.replace(/^0x/i, '');\n\n  if (result.length % 2 !== 0) {\n    throw new Error('Given parameter bytes has an invalid length: \"' + value + '\"');\n  }\n\n  if (result.length > 64) {\n    throw new Error('Given parameter bytes is too long: \"' + value + '\"');\n  }\n\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(result);\n};\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String} value\n * @returns {SolidityParam}\n */\n\n\nvar formatInputDynamicBytes = function (value) {\n  if (!utils.isHexStrict(value)) {\n    throw new Error('Given parameter is not bytes: \"' + value + '\"');\n  }\n\n  var result = value.replace(/^0x/i, '');\n\n  if (result.length % 2 !== 0) {\n    throw new Error('Given parameter bytes has an invalid length: \"' + value + '\"');\n  }\n\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputString = function (value) {\n  if (!_.isString(value)) {\n    throw new Error('Given parameter is not a valid string: ' + value);\n  }\n\n  var result = utils.utf8ToHex(value).replace(/^0x/i, '');\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputBool = function (value) {\n  var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ? '1' : '0');\n  return new SolidityParam(result);\n};\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\n\n\nvar signedIsNegative = function (value) {\n  return new BN(value.substr(0, 1), 16).toString(2).substr(0, 1) === '1';\n};\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BN} right-aligned output bytes formatted to big number\n */\n\n\nvar formatOutputInt = function (param) {\n  var value = param.staticPart();\n\n  if (!value && !param.rawValue) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  } // check if it's negative number\n  // it it is, return two's complement\n\n\n  if (signedIsNegative(value)) {\n    return new BN(value, 16).fromTwos(256).toString(10);\n  }\n\n  return new BN(value, 16).toString(10);\n};\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam} param\n * @returns {BN} right-aligned output bytes formatted to uint\n */\n\n\nvar formatOutputUInt = function (param, name) {\n  var value = param.staticPart();\n\n  if (!value && !param.rawValue) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  return new BN(value, 16).toString(10);\n};\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam} param\n * @param {String} name type name\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\n\n\nvar formatOutputBool = function (param, name) {\n  var value = param.staticPart();\n\n  if (!value && !param.rawValue) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  return value === '0000000000000000000000000000000000000000000000000000000000000001';\n};\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} param left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\n\n\nvar formatOutputBytes = function (param, name) {\n  var matches = name.match(/^bytes([0-9]*)/);\n  var size = parseInt(matches[1]);\n\n  if (param.staticPart().slice(0, 2 * size).length !== size * 2) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue + ' The size doesn\\'t match.');\n  }\n\n  return '0x' + param.staticPart().slice(0, 2 * size);\n};\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} param left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\n\n\nvar formatOutputDynamicBytes = function (param, name) {\n  var hex = param.dynamicPart().slice(0, 64);\n\n  if (!hex) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  var length = new BN(hex, 16).toNumber() * 2;\n  return '0x' + param.dynamicPart().substr(64, length);\n};\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\n\n\nvar formatOutputString = function (param) {\n  var hex = param.dynamicPart().slice(0, 64);\n\n  if (!hex) {\n    throw new Error('ERROR: The returned value is not a convertible string:' + hex);\n  }\n\n  var length = new BN(hex, 16).toNumber() * 2;\n  return length ? utils.hexToUtf8('0x' + param.dynamicPart().substr(64, length).replace(/^0x/i, '')) : '';\n};\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} param right-aligned input bytes\n * @param {String} name type name\n * @returns {String} address\n */\n\n\nvar formatOutputAddress = function (param, name) {\n  var value = param.staticPart();\n\n  if (!value) {\n    throw new Error('Couldn\\'t decode ' + name + ' from ABI: 0x' + param.rawValue);\n  }\n\n  return utils.toChecksumAddress(\"0x\" + value.slice(value.length - 40, value.length));\n};\n\nmodule.exports = {\n  formatInputInt: formatInputInt,\n  formatInputBytes: formatInputBytes,\n  formatInputDynamicBytes: formatInputDynamicBytes,\n  formatInputString: formatInputString,\n  formatInputBool: formatInputBool,\n  formatOutputInt: formatOutputInt,\n  formatOutputUInt: formatOutputUInt,\n  formatOutputBool: formatOutputBool,\n  formatOutputBytes: formatOutputBytes,\n  formatOutputDynamicBytes: formatOutputDynamicBytes,\n  formatOutputString: formatOutputString,\n  formatOutputAddress: formatOutputAddress,\n  toTwosComplement: utils.toTwosComplement\n};","map":null,"metadata":{},"sourceType":"script"}